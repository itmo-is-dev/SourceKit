using System.Collections;
using FluentChaining;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.DependencyInjection;
using SourceKit.Extensions;
using SourceKit.Generators.Builder.Builders.BuilderTypeBuilders;
using SourceKit.Generators.Builder.Builders.FileBuilders;
using SourceKit.Generators.Builder.Builders.TypeBuilders;
using SourceKit.Generators.Builder.Builders.UsingBuilders;
using SourceKit.Generators.Builder.Commands;
using SourceKit.Generators.Builder.Models;
using SourceKit.Generators.Builder.Receivers;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace SourceKit.Generators.Builder.Generators;

[Generator]
public class BuilderSourceGenerator : ISourceGenerator
{
    private readonly IChain<FileBuildingCommand, CompilationUnitSyntax> _chain;

    public BuilderSourceGenerator()
    {
        var collection = new ServiceCollection();

        collection.AddFluentChaining(x => x.ChainLifetime = ServiceLifetime.Singleton)
            .AddChain<FileBuildingCommand, CompilationUnitSyntax>
            (
                start => start
                    .Then<UsingBuilder>()
                    .Then<PropertyTypesUsingBuilder>()
                    .Then<TypeBuilder>()
                    .FinishWith((r, _) => r.CompilationUnit)
            )
            .AddChain<TypeBuildingCommand, TypeDeclarationSyntax>
            (
                start => start
                    .Then<BuildMethodTypeBuilder>()
                    .Then<BuilderTypeBuilder>()
                    .FinishWith((r, _) => r.Syntax)
            )
            .AddChain<UsingBuildingCommand, UsingDirectiveSyntax>
            (
                start => start
                    .Then<AutoGeneratedCommentBuilder>()
                    .Then<PragmaBuilder>()
                    .FinishWith((r, _) => r.Syntax)
            )
            .AddChain<BuilderTypeBuildingCommand, TypeDeclarationSyntax>
            (
                start => start
                    .Then<FieldBuilderTypeBuilder>()
                    .Then<ConstructorBuilderTypeBuilder>()
                    .Then<CollectionMethodBuilderTypeBuilder>()
                    .Then<ValueMethodBuilderTypeBuilder>()
                    .Then<BuildMethodBuilderTypeBuilder>()
                    .FinishWith((r, _) => r.BuilderSyntax)
            );

        ServiceProvider? provider = collection.BuildServiceProvider();

        _chain = provider.GetRequiredService<IChain<FileBuildingCommand, CompilationUnitSyntax>>();
    }

    public DiagnosticDescriptor FailureDescriptor { get; } = new DiagnosticDescriptor(
        "SK2000",
        "Failed to generate builder",
        "Failed to generate builder. Error: {0}",
        "Usage",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static string GetFileName(string typeName)
    {
        return $"{typeName}.{Constants.FilenameSuffix}";
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new BuilderAttributeSyntaxContextReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        if (context.SyntaxContextReceiver is not BuilderAttributeSyntaxContextReceiver receiver)
            return;

        foreach (INamedTypeSymbol? typeSymbol in receiver.TypeSymbols)
        {
            GenerateForType(context, typeSymbol);
        }
    }

    private void GenerateForType(GeneratorExecutionContext context, INamedTypeSymbol symbol)
    {
        try
        {
            BuilderProperty[] properties = symbol
                .GetMembers()
                .OfType<IPropertySymbol>()
                .Where(x => x.IsImplicitlyDeclared is false)
                .Where(x => x.IsAutoProperty())
                .Select(x => MapToBuilderProperty(symbol, x, context.Compilation))
                .ToArray();

            var fileCommand = new FileBuildingCommand(
                context,
                CompilationUnit(),
                symbol,
                properties);

            CompilationUnitSyntax compilationUnit = _chain.Process(fileCommand);
            string fileName = GetFileName(symbol.Name);

            context.AddSource(fileName, compilationUnit.NormalizeWhitespace(eol: "\n").ToFullString());
        }
        catch (Exception e)
        {
            var diagnostic = Diagnostic.Create(
                FailureDescriptor,
                symbol.GetSignatureLocations().First(),
                e.Message);

            context.ReportDiagnostic(diagnostic);
        }
    }

    private static BuilderProperty MapToBuilderProperty(
        INamedTypeSymbol type,
        IPropertySymbol propertySymbol,
        Compilation compilation)
    {
        ITypeSymbol propertyType = propertySymbol.Type;
        INamedTypeSymbol enumerableType = compilation.GetTypeSymbol<IEnumerable>();

        INamedTypeSymbol constructorParameterAttribute = compilation
            .GetTypeSymbol(Constants.BuilderConstructorParameterAttributeFullyQualifiedName);

        IParameterSymbol recordConstructorParameter = type.Constructors
            .SelectMany(x => x.Parameters)
            .Single(x => x.Name.Equals(propertySymbol.Name));

        bool isBuilderConstructorParameter =
            propertySymbol.GetAttributes().HasAttribute(constructorParameterAttribute)
            || recordConstructorParameter.GetAttributes().HasAttribute(constructorParameterAttribute);

        object? defaultValue = type.Constructors
            .SelectMany(x => x.Parameters)
            .Where(x => x.Name.Equals(propertySymbol.Name))
            .Where(x => x.HasExplicitDefaultValue)
            .Select(x => x.ExplicitDefaultValue)
            .WhereNotNull()
            .SingleOrDefault();

        var literalValue = new LiteralValue(defaultValue);

        if (propertyType is not IArrayTypeSymbol && propertyType.IsAssignableTo(enumerableType) is false)
            return new BuilderProperty.Value(propertySymbol, propertyType, literalValue, isBuilderConstructorParameter);

        INamedTypeSymbol stringType = compilation.GetTypeSymbol<string>();

        if (propertyType.Equals(stringType, SymbolEqualityComparer.Default))
            return new BuilderProperty.Value(propertySymbol, propertyType, literalValue, isBuilderConstructorParameter);

        ITypeSymbol elementType = propertyType.GetEnumerableTypeArgument(compilation);

        if (propertyType is IArrayTypeSymbol)
        {
            return new BuilderProperty.Collection(
                propertySymbol,
                CollectionKind.Array,
                elementType,
                isBuilderConstructorParameter);
        }

        INamedTypeSymbol listType = compilation.GetTypeSymbol(typeof(List<>)).Construct(elementType);

        if (propertyType.Equals(listType, SymbolEqualityComparer.Default))
        {
            return new BuilderProperty.Collection(
                propertySymbol,
                CollectionKind.List,
                elementType,
                isBuilderConstructorParameter);
        }

        INamedTypeSymbol setType = compilation.GetTypeSymbol(typeof(HashSet<>)).Construct(elementType);

        if (propertyType.Equals(setType, SymbolEqualityComparer.Default))
        {
            return new BuilderProperty.Collection(
                propertySymbol,
                CollectionKind.HashSet,
                elementType,
                isBuilderConstructorParameter);
        }

        return new BuilderProperty.Collection(
            propertySymbol,
            CollectionKind.Array,
            elementType,
            isBuilderConstructorParameter);
    }
}