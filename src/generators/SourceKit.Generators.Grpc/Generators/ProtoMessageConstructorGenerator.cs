using FluentChaining;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.DependencyInjection;
using SourceKit.Extensions;
using SourceKit.Generators.Grpc.Builders.FileBuilders;
using SourceKit.Generators.Grpc.Builders.TypeBuilders;
using SourceKit.Generators.Grpc.Builders.UsingBuilders;
using SourceKit.Generators.Grpc.Commands;
using SourceKit.Generators.Grpc.Models;
using SourceKit.Generators.Grpc.Receivers;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace SourceKit.Generators.Grpc.Generators;

[Generator]
public class ProtoMessageConstructorGenerator : ISourceGenerator
{
    private readonly IChain<FileBuildingCommand, CompilationUnitSyntax> _chain;

    public ProtoMessageConstructorGenerator()
    {
        var collection = new ServiceCollection();

        collection.AddFluentChaining(x => x.ChainLifetime = ServiceLifetime.Singleton)
            .AddChain<FileBuildingCommand, CompilationUnitSyntax>
            (
                start => start
                    .Then<UsingBuilder>()
                    .Then<TypeFileBuilder>()
                    .FinishWith((r, _) => r.CompilationUnit)
            )
            .AddChain<UsingBuildingCommand, UsingDirectiveSyntax>
            (
                start => start
                    .Then<AutoGeneratedCommentBuilder>()
                    .Then<PragmaBuilder>()
                    .FinishWith((r, _) => r.Syntax)
            )
            .AddChain<TypeBuildingCommand, TypeDeclarationSyntax>
            (
                start => start
                    .Then<ConstructorTypeBuilder>()
                    .FinishWith((r, _) => r.Syntax)
            );

        var provider = collection.BuildServiceProvider();
        _chain = provider.GetRequiredService<IChain<FileBuildingCommand, CompilationUnitSyntax>>();
    }

    public DiagnosticDescriptor FailureDescriptor { get; } = new DiagnosticDescriptor(
        "SK2100",
        "Failed to generate proto message constructor",
        "Failed to generate proto message constructor. Error: {0}, at {1}",
        "Usage",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static string GetFileName(string typeName)
    {
        return $"{typeName}.{Constants.FilenameSuffix}";
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ProtoMessageConstructorReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        if (context.SyntaxContextReceiver is not ProtoMessageConstructorReceiver receiver)
            return;

        foreach (var message in receiver.Messages)
        {
            GenerateMessageConstructor(message, context);
        }
    }

    private void GenerateMessageConstructor(ProtoMessage message, GeneratorExecutionContext context)
    {
        try
        {
            var command = new FileBuildingCommand(context, CompilationUnit(), message);
            var compilationUnit = _chain.Process(command);
            var fileName = GetFileName(message.Type.Name);

            var source = compilationUnit.NormalizeWhitespace().ToFullString().Replace("\r\n", "\n");
            context.AddSource(fileName, source);
        }
        catch (Exception e)
        {
            var diagnostic = Diagnostic.Create(
                FailureDescriptor,
                message.Type.GetSignatureLocations().First(),
                e.Message,
                e.Source);

            context.ReportDiagnostic(diagnostic);
        }
    }
}